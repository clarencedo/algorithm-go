# [366.Find Leaves of Binary Tree](https://leetcode.com/problems/find-leaves-of-binary-tree/)
# [366.寻找二叉树的叶子节点](https://leetcode-cn.com/problems/find-leaves-of-binary-tree/)

## 题目

给你一棵二叉树的 root 节点，请按照以下方式收集树的节点：
- 收集所有的叶子节点
- 移除所有的叶子节点
- 重复以上步骤，直到整棵树为空

**Example 1:**

    Input: root = [1,2,3,4,5]
    Output:[[4,5,3],[2],[1]]
    Explanation:[[3,5,4],[2],[1]] 和[[3,4,5],[2],[1]] 也是正确的答案。

![](./1.png)
**Example 2:**

    Input: root = [1]
    Output: [[1]]

**Note:**
- 树中结点的数目在范围 **[0, 100]** 内
- **-100 <= Node.val <= 100**

## 核心思想
- 什么是“深度”
深度 是指一个节点到叶子节点的最长路径上的节点数（包括自己）。
叶子节点的深度为 0，因为它们本身就是最底层，没有子节点。
非叶子节点的深度可以通过递归计算：
节点深度 = max(左子树深度, 右子树深度) + 1
- 目标
对二叉树中每个节点，按照深度进行分组。
深度为 0 的节点是叶子节点，最先被移除。
深度为 1 的节点是移除所有叶子节点后形成的新叶子节点。
以此类推，直到整棵树被“移除”。

## 递归设计的思路

### 后序遍历
二叉树的 后序遍历 是从叶子节点到根节点的遍历顺序，刚好与分组节点的逻辑吻合。
在递归中，每个节点需要知道其子节点的状态（深度），才能决定自身的深度。

### 核心逻辑
- 从底向上递归计算深度：

如果当前节点是叶子节点（左右子节点均为 nil），深度为 0。
如果当前节点有子节点，深度等于 max(左子节点深度, 右子节点深度) + 1。

- 按深度存储节点值：

用一个二维数组 res 存储不同深度的节点值。
每当发现新深度时，扩展数组以存储该层的节点。
递归返回值：

每次递归返回当前节点的深度，供父节点计算自身深度。

