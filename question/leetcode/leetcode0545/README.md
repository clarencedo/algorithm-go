# [545.二叉树的边界](https://leetcode.cn/problems/boundary-of-binary-tree/description/?envType=study-plan-v2&envId=premium-algo-100)

## 题目

二叉树的**边界**是由**根节点**、**左边界** 、按从左到右顺序的**叶节点**和**逆序的右边界**，按顺序依次连接组成。

**左边界**是满足下述定义的节点集合：

- 根节点的左子节点在左边界中。如果根节点不含左子节点，那么左边界就为 空 。
- 如果一个节点在左边界中，并且该节点有左子节点，那么它的左子节点也在左边界中。
- 如果一个节点在左边界中，并且该节点 不含 左子节点，那么它的右子节点就在左边界中。
- 最左侧的叶节点 不在 左边界中。

**右边界** 定义方式与**左边界**相同，只是将左替换成右。即，右边界是根节点右子树的右侧部分；叶节点**不是** 右边界的组成部分；如果根节点不含右子节点，那么右边界为**空**。

**叶节点**是没有任何子节点的节点。对于此问题，**根节点**不是**叶节点**。


**Example 1:**

    Input: root = [1,null,2,3,4]
    Output: [1,3,4,2]
    Explanation:
    - 左边界为空，因为二叉树不含左子节点。
    - 右边界是 [2] 。从根节点的右子节点开始的路径为 2 -> 4 ，但 4 是叶节点，所以右边界只有 2 。
    - 叶节点从左到右是 [3,4] 。
    按题目要求依序连接得到结果 [1] + [] + [3,4] + [2] = [1,3,4,2] 。
![](./1.jpg)

**Example 2:**

    Input: root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
    Output: [1,2,4,7,8,9,10,6,3]
    Explanation:
    - 左边界为 [2] 。从根节点的左子节点开始的路径为 2 -> 4 ，但 4 是叶节点，所以左边界只有 2 。
    - 右边界是 [3,6] ，逆序为 [6,3] 。从根节点的右子节点开始的路径为 3 -> 6 -> 10 ，但 10 是叶节点。
    - 叶节点从左到右是 [4,7,8,9,10]
    按题目要求依序连接得到结果 [1] + [2] + [4,7,8,9,10] + [6,3] = [1,2,4,7,8,9,10,6,3] 。
![](./2.jpg)

**Note:**
- 树中结点的数目在范围 **[0, 100]** 内
- **-100 <= Node.val <= 100**

## 核心思想
- 什么是“深度”
深度 是指一个节点到叶子节点的最长路径上的节点数（包括自己）。
叶子节点的深度为 0，因为它们本身就是最底层，没有子节点。
非叶子节点的深度可以通过递归计算：
节点深度 = max(左子树深度, 右子树深度) + 1
- 目标
对二叉树中每个节点，按照深度进行分组。
深度为 0 的节点是叶子节点，最先被移除。
深度为 1 的节点是移除所有叶子节点后形成的新叶子节点。
以此类推，直到整棵树被“移除”。

## 递归设计的思路

### 后序遍历
二叉树的 后序遍历 是从叶子节点到根节点的遍历顺序，刚好与分组节点的逻辑吻合。
在递归中，每个节点需要知道其子节点的状态（深度），才能决定自身的深度。

### 核心逻辑
- 从底向上递归计算深度：

如果当前节点是叶子节点（左右子节点均为 nil），深度为 0。
如果当前节点有子节点，深度等于 max(左子节点深度, 右子节点深度) + 1。

- 按深度存储节点值：

用一个二维数组 res 存储不同深度的节点值。
每当发现新深度时，扩展数组以存储该层的节点。
递归返回值：

每次递归返回当前节点的深度，供父节点计算自身深度。

