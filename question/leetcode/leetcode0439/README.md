# [438. 三元表达式解析器](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

## 题目
给定一个表示任意嵌套三元表达式的字符串`expression`，求值并返回其结果。

你可以总是假设给定的表达式是有效的，并且只包含数字， `'?'` ，  `':'` ，  `'T'` 和 `'F'` ，其中 `'T'` 为真， `'F'`为假。表达式中的所有数字都是 一位 数(即在 **[0,9]** 范围内)。

条件表达式从右到左分组(大多数语言中都是这样)，表达式的结果总是为数字 `'T'` 或`'F'` 。

**Example 1:**

    输入： expression = "T?2:3"
    输出： "2"
    解释： 如果条件为真，结果为 2；否则，结果为 3。

**Example 2:**

    输入： expression = "F?1:T?4:5"
    输出： "4"
    解释： 条件表达式自右向左结合。使用括号的话，相当于：
    "(F ? 1 : (T ? 4 : 5))" --> "(F ? 1 : 4)" --> "4"
    or "(F ? 1 : (T ? 4 : 5))" --> "(T ? 4 : 5)" --> "4"

**Example 3:**

    输入： expression = "T?T?F:5:3"
    输出： "F"
    解释： 条件表达式自右向左结合。使用括号的话，相当于：
    "(T ? (T ? F : 5) : 3)" --> "(T ? F : 3)" --> "F"
    "(T ? (T ? F : 5) : 3)" --> "(T ? F : 5)" --> "F"


**Note:**

- All of the nodes' values will be unique.
- p and q are different and both values will exist in the binary tree.
- `5 <= expression.length <= 104`
- `expression` 仅包含数字、 `'T'`、 `'F'`、 `'?'` 和 `':'` 。
- `expression` 是一个有效的三元表达式。

## 题目大意



## 解题思路

### 栈
- 从右向左遍历表达式，遇到数字直接入栈
- 这样可以在遇到 `?` 时，直接弹出栈顶两个元素，计算 `condition` 的值，如果为真，入栈 `true_case`
的值，否则入栈 `false_case` 的值

### 递归
- 遇到?开始拆解表达式，分割为 `condition` 和 `true_case` 和 `false_case` 三部分
- 递归计算 `condition` 的值，如果为真，递归计算 `true_case` 的值，否则递归计算 `false_case` 的值
- 在计算`true_case`和`false_case`的时候继续拆解直到没有`?`


## 对比递归和迭代


| 特性   | 递归 |     迭代 |
| :----- | :--: | -------: |
| 实现复杂度|  较低，逻辑符合表达式定义  | 较高，需要手动维护栈和边界|
| 性能|  稍低，受栈递归限制| 较高，效率较优|
| 代码清晰度|  高,可读性强| 较低，逻辑复杂度高|
| 适用场景|  嵌套层次较少，表达式较小的场景| 嵌套层次深，或性能要求较高的场景|

如果表达式嵌套层数较多，建议选择迭代实现；如果嵌套层次较少且更关注代码简洁性，可以优先考虑递归方法。
