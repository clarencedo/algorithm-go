# [1060.有序数组中的缺失元素](https://leetcode.cn/problems/missing-element-in-sorted-array/?envType=study-plan-v2&envId=premium-algo-100)
## 题目

现有一个按**升序**排列的整数数组`nums` ,其中每个数字都**互不相同** 。

给你一个整数 `k` ，请你找出并返回从数组最左边开始的第 k 个缺失数字。



**示例 1：**

    输入：nums = [4,7,9,10], k = 1
    输出：5
    解释：第一个缺失数字为 5 。

**示例 2：**

    输入：nums = [4,7,9,10], k = 3
    输出：8
    解释：缺失数字有 [5,6,8,...]，因此第三个缺失数字为 8 。

**示例 3：**

    输入：nums = [1,2,4], k = 3
    输出：6
    解释：缺失数字有 [3,5,6,7,...]，因此第三个缺失数字为 6 。


**提示：**

- `1 <= nums.length <= 5 * 104 `
- `1 <= nums[i] <= 107 `
- `nums 按 升序 排列，其中所有元素 互不相同`。
- `1 <= k <= 108 `

**进阶：**

如果时间复杂度为 O(logn) ，并且只使用 O(1) 额外空间复杂度，该怎么做呢？

## 题目大意

按层序从上到下遍历一颗树，计算每一层的平均值。

## 解题思路

### 1. 定义缺失数量
- 对于一个升序数组，在索引i之前的缺失数字数量可以通过公式计算:
    $$ missing = nums[i] - nums[0] - i $$
- 解释：
  - **nums[i] − nums[0]** 是假设没有缺失数字时，应该存在的整数数量。
  - 减去**i**是实际存在的数字数量，差值即为缺失的数量。

### 2. 问题转换
- 我们需要找到第k个缺失数字，可以通过找最右边满足`missing(i) < k`的索引i。

### 3. 二分查找
- 使用二分查找满足条件的索引**i**,然后根据公式计算第k个缺失数字。

### 4. 关键公式
- 如果i是我们找到的索引，且**missing(i) < k**,则第**k**个缺失数字为：
    $$ nums[i] + k - missing(i) $$